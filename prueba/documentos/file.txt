Hola Mundo!

let linkstxtarr = readFile(file).match(regex)
    if(linkstxtarr !== null){
     let result = md.render(readFile(file)); //"render()" se usa para renderizar el contenido del archivo. EnLa variable "result" se almacena el resultado de la renderización.
     const dom = new JSDOM(result);
     linkstxtarr = dom.window.document.querySelector("<a>")
    }


regex:/\[(.+?)\]\((https?:\/\/[^\s]+)(?: "(.+)")?\)|(https?:\/\/[^\s]+)/ig;
    
    
//   Saber sí la ruta es relativa ó 'absoluta'  || resolve recorre el sistema de archivos.
const absolutePath = (filePath) => {
    if (path.isAbsolute(filePath) ? filePath : path.resolve(filePath)) {
        // Devuelve la ruta absoluta
        console.log(`ruta resuelta: ${absolutePath}`)
    }
}

 es ruta absoluta ? cambiarla absoluta
if (path.isAbsolute(filePath)) {
       return absolutePath
     } else if  (path.resolve(filePath)){
        console.log(`ruta resuelta`)
     }



 const promises = []
    promises = links.map((link) => axios({
    method: 'GET',
    url: link.href,
    
    })
        .then((res) => {
            if ( res.status >= 200 && res.status < 300) { // si la solicitud fue exitosa

                return {

                    href: link.href,
                    text: link.text,
                    file: link.file,
                    ok: (res.ok)
                };
            }
        })
        .catch((err) => {
            (err.status >= 400)
            return {

                href: link.href,
                text: link.text,
                file: link.file,
                status: res.response ? 404 : "ERROR",
                ok: 'Fail',
           };
        })
    )
    return Promise.all(promises);


    const regex = /(\[(.*?)\])(\((.*?)\))/gim;
    let match = regex.exec(filePath)
    for (let i = 0; i < filePath.length; i++) {
        if (match !== null) {
            let matches = match;
            promises.push(fetch(match[3])
                .then((response) => {
                    return {
                        href: matches[3],
                        text: matches[2],
                        file: filePath,
                        status: response.status,
                        ok: (response.status) ? 'ok' : fail,
                    }
                }))
            matches = regex.exec(filePath)
        }
    } return Promise.all(promises);

    // Comprobar si la ruta es un archivo , directorio o una una ruta invalida
// const checkFileOrDir = (filePath) => {
//     const stats = fs.statSync(filePath)
//     if (stats.isFile(filePath)) {
//         console.log("Path is file:", stats.isFile());
//         marKdown(filePath)

//     } else if (stats.isDirectory(filePath)) {
//         console.log("Path is directory:", stats.isDirectory());
//         readDirectory(filePath)
//     } else {
//         console.log('No es un archivo ni directorio - ruta inválida')
//     }
// }


// const readFileasyncValidated = (filePath) => fsp.readFile(filePath)
//      .then((data) =>{
//         return getLinksValidated(filePath,data)
//     })
//     .catch((err) => {
//      console.log(err, 'No se ha encontrado un archivo')
//     })
    

    otra manera de validar links con axios
      return Promise.all(links.map((data) => axios.get(data.href)
//         .then((result) => {
//             // console.log(result.status,' verificando estado')
//             const objetValidate = {
//                 ...data, // objeto de propagacion 
//                 status: result.status,
//                 ok: result.statusText ? 'ok' : 'fail',
//             }
//             return objetValidate
//         })
//         .catch((err) => {
//             // console.log(err.status)
//             let respuesta = err.response
//             const objetcValidate = {
//                 ...data,
//                 status: err?.response?.status,
//                 ok: 'fail',
//             }
//             return objetcValidate
//         })
//     ))
// 


